#!{{context.build_env_exe}}

import sys
import importlib
import argparse
import logging
import pathlib
import re
import subprocess
import tempfile


try:
    import importlib.metadata

    def _get_package(name):
        try:
            dist = importlib.metadata.distribution(name)
            return dist.version
        except importlib.metadata.PackageNotFoundError:
            return None

except ImportError:
    import pkg_resources

    def _get_package(name):
        try:
            dist = pkg_resources.get_distribution(name)
            return dist.version
        except pkg_resources.DistributionNotFound:
            return None


logger = logging.getLogger()
EXPOSED_LIBS = {{repr(context.exposed_libs)}}


def install_fake_wheel(name, version):
    # https://packaging.python.org/en/latest/specifications/name-normalization/#name-normalization
    name = re.sub(r"[-_.]+", "-", name).lower()
    wheel_dist = name.replace("-", "_")

    with tempfile.TemporaryDirectory() as tname:
        tpath = pathlib.Path(tname)
        dist_info = tpath / f"{wheel_dist}-{version}.dist-info"
        dist_info.mkdir(parents=True, exist_ok=True)

        with open(dist_info / "METADATA", "w") as fp:
            fp.write(
                "Metadata-Version: 2.1\n" f"Name: {name}\n" f"Version: {version}\n"
            )

        with open(dist_info / "WHEEL", "w") as fp:
            fp.write(
                "Wheel-Version: 1.0\n"
                "Generator: crossenv\n"
                "Root-Is-Purelib: true\n"
                "Tag: py3-none-any\n"
            )

        subprocess.check_call(
            [
                {{repr(context.sys_executable)}},
                "-m",
                "wheel",
                "pack",
                tname,
                "--dest-dir",
                tname,
            ]
        )

        whl = list(tpath.glob("*.whl"))[0]

        subprocess.check_call(
            [
                {{repr(context.cross_env_exe)}},
                "-m",
                "pip",
                "--disable-pip-version-check",
                "install",
                str(whl),
            ]
        )


def get_exposed():
    exposed = set()
    try:
        with open(EXPOSED_LIBS, "r") as fp:
            for line in fp:
                item = line.split("#", 1)[0].strip()
                if not item:
                    continue
                exposed.add(item)
    except IOError:
        pass
    return exposed


def list_exposed():
    exposed = get_exposed()
    for name in sorted(exposed):
        print(name)


def expose_packages(names, unexpose=False):
    exposed = get_exposed()
    names = set(names)
    added = set()
    removed = []

    if not unexpose:
        for name in names:
            if name in exposed:
                continue
            version = _get_package(name)
            if version is not None:
                exposed.add(name)
                added.add((name, version))
            else:
                logger.warning("%r was not found in build-python. Skipping.", name)

    else:
        for name in names:
            if name not in exposed:
                logger.warning("%r was not exposed. Skipping.", name)
            else:
                exposed.remove(name)
                removed.append(name)

    for name, version in added:
        install_fake_wheel(name, version)

    if removed:
        subprocess.check_call(
            [
                {{repr(context.cross_env_exe)}},
                "-m",
                "pip",
                "--disable-pip-version-check",
                "uninstall",
                "-y",
            ]
            + removed
        )

    with open(EXPOSED_LIBS, "w") as fp:
        for item in sorted(exposed):
            print(item, file=fp)


def get_all_modules():
    from pip.operations.freeze import freeze

    DEV_PKGS = ("pip", "setuptools", "distribute", "wheel")
    installed = freeze(local_only=True, skip=DEV_PKGS)
    return [req.split("==")[0] for req in installed]


def main():
    parser = argparse.ArgumentParser(
        description="""Let cross-pip, setup.py, etc. see packages installed in
                       build-python. This is mainly useful for getting around
                       setup_requires."""
    )
    parser.add_argument(
        "-l", "--list", action="store_true", help="""List currently exposed packages"""
    )
    parser.add_argument(
        "-u",
        "--unexpose",
        action="store_true",
        help="""Undo the effects of an eariler %(prog)s call""",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="""Verbose mode. May be specified multiple times to increase
                    verbosity.""",
    )
    parser.add_argument(
        "MODULE",
        nargs="*",
        help="""Module(s) to expose (or unexpose) to cross-python. If the
                    special name :all: is encountered, all modules, as reported
                    by 'pip freeze' will be exposed.""",
    )

    args = parser.parse_args()

    if args.verbose == 1:
        level = logging.INFO
    elif args.verbose > 1:
        level = logging.DEBUG
    else:
        level = logging.WARNING
    logging.basicConfig(level=level, format="%(levelname)s: %(message)s")

    if args.list:
        list_exposed()
        sys.exit(0)

    if not args.MODULE:
        parser.error("At least one MODULE name is required")

    if args.unexpose:
        action = "unexpose"
    else:
        action = "expose"

    exit_code = 0

    try:
        if ":all:" in args.MODULE:
            args.MODULE = get_all_modules()
            logger.info("All modules:")
            for m in args.MODULE:
                logger.info(m)

        expose_packages(args.MODULE, args.unexpose)
    except Exception as e:
        exit_code = 1
        logger.error("Cannot %s %s: %s", action, args.MODULE, e)
        logger.error("Traceback:", exc_info=True)

    sys.exit(exit_code)


if __name__ == "__main__":
    main()
